\documentclass[a4paper, 11pt, oneside]{book}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}   % Babel, replace with your language
\usepackage[T1]{fontenc}      % Font encoding
\usepackage{lmodern,cmap}     % lmodern font, correctly copyable characters in pdf

\usepackage{hyperref}
%\usepackage[hidelinks]{hyperref}
\usepackage{color}
\usepackage{setspace}
\usepackage{caption}

\usepackage{geometry}
\newgeometry{left=3.6cm, right=2.6cm, top=3.0cm, bottom=2.7cm}

\usepackage{amsmath}
\usepackage{amsfonts}

\makeatletter
\newif\if@restonecol
\makeatother

%ALGORITHM
\let\algorithm\relax
\let\endalgorithm\relax
\usepackage[linesnumbered,ruled,algonl,vlined]{algorithm2e}
\newcommand\mycommentfont[1]{\footnotesize \ttfamily \textcolor{blue}{#1}}
\SetCommentSty{mycommentfont}
\newcounter{algoline}

%GRAPHICS
\usepackage{graphicx}
\usepackage{epstopdf}
\DeclareGraphicsExtensions{.pdf,.eps,.png,.jpg,.mps}
\usepackage{placeins} % for \FloatbBarrier

%HEADER FOOTER
\usepackage{fancyhdr}
\fancyhf{}
\fancyhead[LO]{\slshape \rightmark}
\fancyhead[LE]{\slshape \leftmark}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.0mm}
\renewcommand{\footrulewidth}{0.0mm}
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markright{\thechapter.\ #1}{}} %\chaptername\ 
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\renewcommand{\MakeUppercase}[1]{#1} % Get rid of CONTENTS BIBLIOGRAPHY upper cases


\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}

\frenchspacing \sloppy

\newcommand*{\perm}[2]{{}^{#1}\!P_{#2}}%
\newcommand*{\comb}[2]{{}^{#1}C_{#2}}%

\newcommand{\eat}[1]{}
\hyphenation{}

\begin{document}

\title{Ensemble Learning in Data Streams}


\author{
Hossain Mahmud \\
Technische Universit\"at M\"unchen\\
mahmud@in.tum.de\\
}

\date{}

%\maketitle
\pagenumbering{roman}
\onehalfspacing
\addcontentsline{toc}{chapter}{Contents}
\tableofcontents
\clearpage

\listoftables
\addcontentsline{toc}{chapter}{List of Tables}
\clearpage

\listoffigures
\addcontentsline{toc}{chapter}{List of Figures}
\clearpage

\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}
\clearpage

%\normalsize
\onehalfspacing
\pagenumbering{arabic}
\setcounter{page}{1}


\input{introduction.tex}
\input{literature.tex}
\input{background.tex}
\input{dataset.tex}


\chapter{Algorithms}
\label{chp:algo}
In the previous chapters, we have presented the motivations, fundamental concepts, solution overview of this thesis. We have also presented the dataset generation process. Now, in this chapter, we present our algorithms, Size Restricted Hoeffding Tree (SRHT) and Carry-over bagging. Size restricted Hoeffding tree is extended from original Hoeffding tree algorithm and incorporates ADWIN method. Carry-over bagging is developed over the concepts of Oza online bagging approach.

Before, discussing the algorithms, we define our problem mathematically and re-state the solution overview.

\section{Problem Statement}
\section{Solution Overview}

\section{Size Restricted Hoeffding Tree (SRHT)}
This adaptive Hoeffding Tree uses ADWIN to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate.

\begin{algorithm}[htbp]
    \caption{SRHT: Size Restricted Hoeffding Tree}
    \label{alg:srht}
    \DontPrintSemicolon
    \SetKwInOut{Input}{Input} \SetKwInOut{Output}{Output} 
    
    \Input{$S$: Stream of examples \\
        $X$: Set of nominal attributes \\
        $Y$: Set of class labels $Y = \{y_1, y_2, \dots, y_k\}$ \\
        $G(.)$: Split evaluation function \\
        $N_{min}$: Minimum number of examples \\
        $\delta$: is one minus the desired probability \\
        $d$: Alternate tree switching bound \\
        $n$: Number of maximum decision nodes \\
        $\tau$: Constant to resolve ties
    } 
    \Output{$HT$: is a decision tree}
    
    \Begin{
        Let $HT \leftarrow$ Empty Leaf (Root)
        \ForEach{$example(x, y_k) \in S$} {
            Traverse the tree $HT$ from root till a leaf $l$ \\
            
            \eIf (\tcp*[f]{Missing class label}) {$y_k == ?$ } {
                Classify with majority class in the leaf $l$
            } {
                Update sufficient statistics \\
                \If{$ Number\;of\;examples\;in\;l > N_{min}$ }{
                    Compute $G_l(X_i)$ for all attributes \\
                    Let $X_a$ be the attribute with highest $G_l$ \\
                    Let $X_b$ be the attribute with second highest $G_l$ \\
                    Start maintaining ADWIN \\
                    
                    \uIf{error increased from previous step} {
                        Start maintaining alternate tree \\
                    }
                    \uElseIf{oldError - alternateError > bound} {
                        \uIf{ADWIN window sufficiently big}{
                            Switch to alternate tree \\
                        }
                        \uElseIf{alternateError - oldError > bound} {
                            Delete alternate tree \\
                        }
                    }
                    
                    Compute $\epsilon = \sqrt{\frac{R^2 \ln(2/\delta)}{2n}}$  \tcp*[f]{Hoeffding bound} \\
                    
                    \If{$G(X_a) - G(X_b) > \epsilon\; || \;\epsilon < \tau$} {
                        \If{decision node count < n} {
                            Replace $l$ with a splitting test based on attribute $X_a$ \\
                            Add a new empty leaf for each branch of the split \\
                        }
                    }
                }
            }
        }
    Return $HT$
    }
\end{algorithm}

\section{Carry-over Bagging with SRHT}
\begin{algorithm}[htbp]
    \caption{CoBag: Carry-Over Bagging with SRHT}
    \label{alg:cobag}
    \DontPrintSemicolon
    \SetKwInOut{Input}{Input} \SetKwInOut{Output}{Output} 
    
    \Input{
        $H$: Set of base learners \\
        $n$: Ensemble size \\
        $m$: Additional ensemble size \\
        $b$: Tree size limit to use additional ensembles
    } 
    \Output{A SRHT ensemble}
    
    \Begin{
        Create $n$ SRHT $H_i$ \\
        \ForEach{$h \in H$} {
            Set $k$ according to $Poisson(1)$ \\
            \For{$i: 1-k$} {
                Learn $h$ with SRHT\\
                \uIf{$h.size > h.maxSize$ and $h.size < b$} {
                    Reset $h$ \\
                }
                \uElseIf {$h.size > h.maxSize$} {
                    Move $h$ to Alternate ensemble \\
                    Create new SRHT with size limit of $h.maxSize$ \\
                    
                    \If{Size of additional ensemble > m} {
                        Delete the oldest $h$ from additional ensemble \\
                    }
                }
            }
        }
        
    }

\end{algorithm}

\section{Summary}

\chapter{Experimental Study}
\label{chp:exp}
\section{Test Study-case with Adult Dataset}
\section{Structural Study of Decision Trees}
\section{Performance Evaluation}
\subsection{Performance Metrics}
\subsection{Traditional Streams}
\subsection{Social Network-like Streams}

\chapter{Conclusion}
\section{Contribution}
\section{Future Works}
\section{Open Issues}

\bibliographystyle{apalike}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{ref}

\end{document}
